From: Ran Shidlansik <ranshid@amazon.com>
Date: Mon, 7 Jul 2025 00:40:08 +0300
Subject: retry accept on transient errors (CVE-2025-48367) (#2315)

Signed-off-by: Ran Shidlansik <ranshid@amazon.com>

Origin: upstream, https://github.com/valkey-io/valkey/commit/cb10d9d78f3594
Bug-Debian: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1108982
Bug-Security: https://security-tracker.debian.org/tracker/CVE-2025-48367
Reviewed-by: Lucas Kanashiro <kanashiro@debian.org>
Last-Updated: 2025-07-09
---
 src/anet.c           | 31 +++++++++++++++++++++++++++++++
 src/anet.h           |  1 +
 src/cluster_legacy.c |  1 +
 src/socket.c         |  1 +
 src/tls.c            |  1 +
 src/unix.c           |  1 +
 6 files changed, 36 insertions(+)

diff --git a/src/anet.c b/src/anet.c
index 140c06c..4f5fab3 100644
--- a/src/anet.c
+++ b/src/anet.c
@@ -639,6 +639,37 @@ int anetUnixServer(char *err, char *path, mode_t perm, int backlog, char *group)
     return s;
 }
 
+/* For some error cases indicates transient errors and accept can be retried
+ * in order to serve other pending connections. This function should be called with the last errno,
+ * right after anetTcpaccept or anetUnixAccept returned an error in order to retry them. */
+int anetRetryAcceptOnError(int err) {
+    /* This is a transient error which can happen, for example, when
+     * a client initiates a TCP handshake (SYN),
+     * the server receives and queues it in the pending connections queue (the SYN queue),
+     * but before accept() is called, the connection is aborted.
+     * in such cases we can continue accepting other connections. ÃŸ*/
+    if (err == ECONNABORTED)
+        return 1;
+
+#if defined(__linux__)
+    /* https://www.man7.org/linux/man-pages/man2/accept4.2 suggests that:
+     * Linux accept() (and accept4()) passes already-pending network
+       errors on the new socket as an error code from accept().  This
+       behavior differs from other BSD socket implementations.  For
+       reliable operation the application should detect the network
+       errors defined for the protocol after accept() and treat them like
+       EAGAIN by retrying.  In the case of TCP/IP, these are ENETDOWN,
+       EPROTO, ENOPROTOOPT, EHOSTDOWN, ENONET, EHOSTUNREACH, EOPNOTSUPP,
+       and ENETUNREACH. */
+    if (err == ENETDOWN || err == EPROTO || err == ENOPROTOOPT ||
+        err == EHOSTDOWN || err == ENONET || err == EHOSTUNREACH ||
+        err == EOPNOTSUPP || err == ENETUNREACH) {
+        return 1;
+    }
+#endif
+    return 0;
+}
+
 /* Accept a connection and also make sure the socket is non-blocking, and CLOEXEC.
  * returns the new socket FD, or -1 on error. */
 static int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {
diff --git a/src/anet.h b/src/anet.h
index b14b4bd..5067ec9 100644
--- a/src/anet.h
+++ b/src/anet.h
@@ -74,5 +74,6 @@ int anetPipe(int fds[2], int read_flags, int write_flags);
 int anetSetSockMarkId(char *err, int fd, uint32_t id);
 int anetGetError(int fd);
 int anetIsFifo(char *filepath);
+int anetRetryAcceptOnError(int err);
 
 #endif
diff --git a/src/cluster_legacy.c b/src/cluster_legacy.c
index c6ea575..dfb0e7b 100644
--- a/src/cluster_legacy.c
+++ b/src/cluster_legacy.c
@@ -1502,6 +1502,7 @@ void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
     while (max--) {
         cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
         if (cfd == ANET_ERR) {
+            if (anetRetryAcceptOnError(errno)) continue;
             if (errno != EWOULDBLOCK) serverLog(LL_VERBOSE, "Error accepting cluster node: %s", server.neterr);
             return;
         }
diff --git a/src/socket.c b/src/socket.c
index 3033d36..98fd512 100644
--- a/src/socket.c
+++ b/src/socket.c
@@ -322,6 +322,7 @@ static void connSocketAcceptHandler(aeEventLoop *el, int fd, void *privdata, int
     while (max--) {
         cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
         if (cfd == ANET_ERR) {
+            if (anetRetryAcceptOnError(errno)) continue;
             if (errno != EWOULDBLOCK) serverLog(LL_WARNING, "Accepting client connection: %s", server.neterr);
             return;
         }
diff --git a/src/tls.c b/src/tls.c
index fddfe1e..8d677b2 100644
--- a/src/tls.c
+++ b/src/tls.c
@@ -789,6 +789,7 @@ static void tlsAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask)
     while (max--) {
         cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
         if (cfd == ANET_ERR) {
+            if (anetRetryAcceptOnError(errno)) continue;
             if (errno != EWOULDBLOCK) serverLog(LL_WARNING, "Accepting client connection: %s", server.neterr);
             return;
         }
diff --git a/src/unix.c b/src/unix.c
index a46bd53..102e4ce 100644
--- a/src/unix.c
+++ b/src/unix.c
@@ -107,6 +107,7 @@ static void connUnixAcceptHandler(aeEventLoop *el, int fd, void *privdata, int m
     while (max--) {
         cfd = anetUnixAccept(server.neterr, fd);
         if (cfd == ANET_ERR) {
+            if (anetRetryAcceptOnError(errno)) continue;
             if (errno != EWOULDBLOCK) serverLog(LL_WARNING, "Accepting client connection: %s", server.neterr);
             return;
         }
