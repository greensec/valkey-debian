From: Zeroday BYTE <github@zerodaysec.org>
Date: Mon, 26 May 2025 18:57:00 +0700
Subject: Fix unsigned difference expression compared to zero (#2101)

https://github.com/valkey-io/valkey/blob/daea05b1e26db29bfd1c033e27f9d519a2f8ccbb/src/networking.c#L886-L886

Fix the issue need to ensure that the subtraction `prev->size -
prev->used` does not underflow. This can be achieved by explicitly
checking that `prev->used` is less than `prev->size` before performing
the subtraction. This approach avoids relying on unsigned arithmetic and
ensures the logic is clear and robust.

The specific changes are:
1. Replace the condition `prev->size - prev->used > 0` with `prev->used
< prev->size`.
2. This change ensures that the logic checks whether there is remaining
space in the buffer without risking underflow.

**References**
[INT02-C. Understand integer conversion
rules](https://wiki.sei.cmu.edu/confluence/display/c/INT02-C.+Understand+integer+conversion+rules)
[CWE-191](https://cwe.mitre.org/data/definitions/191.html)

---

Signed-off-by: Zeroday BYTE <github@zerodaysec.org>

Reviewed-By: Trupti <trupti@linux.ibm.com>,
             Lucas Kanashiro <kanashiro@debian.org>
Origin: upstream, https://github.com/valkey-io/valkey/commit/374718b2a365ca
Bug-Debian: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1107210
Bug-Debian-Security: https://security-tracker.debian.org/tracker/CVE-2025-49112
---
 src/networking.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/networking.c b/src/networking.c
index 8d0af29..0b54308 100644
--- a/src/networking.c
+++ b/src/networking.c
@@ -859,7 +859,7 @@ void setDeferredReply(client *c, void *node, const char *s, size_t length) {
      * - It has enough room already allocated
      * - And not too large (avoid large memmove)
      * - And the client is not in a pending I/O state */
-    if (ln->prev != NULL && (prev = listNodeValue(ln->prev)) && prev->size - prev->used > 0 &&
+    if (ln->prev != NULL && (prev = listNodeValue(ln->prev)) && prev->used < prev->size &&
         c->io_write_state != CLIENT_PENDING_IO) {
         size_t len_to_copy = prev->size - prev->used;
         if (len_to_copy > length) len_to_copy = length;
